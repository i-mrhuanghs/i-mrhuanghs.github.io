<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Django on HansenHung&#39;s blog</title>
    <link>https://i-mrhuanghs.github.io/tags/django/</link>
    <description>Recent content in Django on HansenHung&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Jun 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://i-mrhuanghs.github.io/tags/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Django 流式响应中文csv样例</title>
      <link>https://i-mrhuanghs.github.io/post/django%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94csv%E6%A0%B7%E4%BE%8B/</link>
      <pubDate>Mon, 04 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://i-mrhuanghs.github.io/post/django%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94csv%E6%A0%B7%E4%BE%8B/</guid>
      <description>在Django里，流式响应StreamingHttpResponse是个好东西,可以快速、节省内存地产生一个大型文件。
目前项目里用于流式响应的一个是Eventsource，用于改善跨系统通讯时用户产生的慢速的感觉。这个不细说了。
还有一个就是生成一个大的csv文件。
当Django进程处于gunicorn或者uwsgi等web容器中时，如果响应超过一定时间没有返回，就会被web容器终止掉，虽然我们可以通过加长web容器的超时时间来绕过这个问题，但是毕竟还是治标不治本。要根本上解决这个问题，Python的生成器、Django框架提供的StreamingHttpResponse这个流式响应很有帮助
而在csv中，中文的处理也至关重要，要保证用excel打开csv不乱码什么的。。为了节约空间，我就把所有代码贴到一起了。。实际使用按照项目的规划放置哈
上代码：
from __future__ import absolute_import import csv import codecs import cStringIO class Echo(object): def write(self, value): return value class UnicodeWriter: &amp;#34;&amp;#34;&amp;#34; A CSV writer which will write rows to CSV file &amp;#34;f&amp;#34;, which is encoded in the given encoding. &amp;#34;&amp;#34;&amp;#34; def __init__(self, f, dialect=csv.excel, encoding=&amp;#34;utf-8&amp;#34;, **kwds): # Redirect output to a queue self.queue = cStringIO.StringIO() self.writer = csv.writer(self.queue, dialect=dialect, **kwds) self.stream = f self.encoder = codecs.</description>
    </item>
    
  </channel>
</rss>
